[note-python](https://github.com/lijin-thu/notes-python)
# note-python笔记
 > 作者：齐树豪<br>
 > **Copyright © Qi Shuhao. All Rights Reserved**
 ---
 ## 入门演示
 1. 整数相加，得到整数；浮点数相加，得到浮点数；整数和浮点数相加，得到浮点数；
 2. 使用<变量名>=<表达式>的方式对变量进行赋值;
 3. 字符串的生成，单引号与双引号是等价的；三引号用来输入包含多行文字的字符串；字符串的加法、索引、分割、求长度；
 4. 用[]来生成列表；列表加法、索引、长度、添加元素；
 5. 用{}来生成集合，集合中不含有相同元素；集合的长度、添加元素、交、并、差、对称差；
 6. 用{key:value}来生成Dictionary；查看字典的大小、某个键对应的值、所有键、所有值、所有键值对；
 7. Numpy数组可以进行很多列表不能进行的运算;
 8. [列表/字典/集合推导式](https://www.cnblogs.com/tkqasn/p/5977653.html)
 9. 打开文件f=oprn();写文件f.write();读文件;删除文件f.remove()；
 10. 用关键词def来定义函数;数组参数；定义时指定参数的默认值；
 11. 用import关键词来导入模块；
 12. 用class来定义一个类（Person(object)表示继承自object类；__init__函数用来初始化对象； self表示对象自身，类似于C Java里面this）；构建新对象；调用对象的属性；调用对象的方法；修改对象的属性；修改新属性；
 13. 读取网络数据：
 ```
 url = 'http://ichart.finance.yahoo.com/table.csv?s=GE&d=10&e=5&f=2013&g=d&a=0&b=2&c=1962&ignore=.csv'
 ```
 14. 使用pandas库处理数据
 ## 数据类型
 ### 基本知识
 1. 整型、浮点数、字符串、列表、字典、numpy数组；长整型、布尔型、元组、集合、pandas类型、自定义；
 2. 在Python 2.7中，整型的运算结果只能返回整型，除法的结果也不例外；幂指数2\*\*5;取余32%5;使用type()函数来查看变量类型；
 3. 整型数字的最大最小值：在 32 位系统中，一个整型 4 个字节，最小值 -2,147,483,648，最大值 2,147,483,647；在 64 位系统中，一个整型 8 个字节，最小值 -9,223,372,036,854,775,808，最大值 9,223,372,036,854,775,807；
 4. 长整型的一个标志是后面以字母L结尾；在赋值时强制让类型为长整型；长整型可以与整型在一起进行计算，返回的类型还是长整型;
 5. 浮点数与整数进行运算时，返回的仍然是浮点数；浮点数也可以进行与整数相似的运算，甚至可以取余；注意看 3.4 - 3.2 的结果并不是我们预期的0.2，这是因为浮点数本身储存方式引起的，浮点数本身会存在一点误差；当我们使用print显示时，Python会自动校正这个结果；
 6. Python 使用 j 来表示复数的虚部；实部a.real、虚部a.imag、共轭a.conjugate()；
 7. 在Python中运算是有优先级的，优先级即算术的先后顺序，比如“先乘除后加减”和“先算括号里面的”都是两种优先级的规则，优先级从高到低排列如下：
    - ( ) 括号
    - ** 幂指数运算
    - ‘*’ / // % 乘，除，整数除法，取余运算
    - '+ -' 加减
 8. 绝对值abs（）；取整（）；最大值最小值min()max();
 9. 不要用内置的函数来命名变量，否则会出现意想不到的结果;
 10. 浮点数转整型，只保留整数部分;整型转浮点型;
 11. 科学计数法;16进制，前面加0x修饰，后面使用数字0-9A-F;8进制，前面加0或者0o修饰，后面使用数字0-7;2进制，前面加0b修饰，后面使用数字0或1;
 12. 原地计算+=、*=、-=；
 13. 布尔型可以看成特殊的二值变量，其取值为True和False；可以用表达式构建布尔型变量；Python支持链式比较；
 ### 字符串
 1. Python中可以使用一对单引号''或者双引号""生成字符串；
 2. 简单操作：加法、乘法、求长度；
 3. Python是一种面向对象的语言，面向对象的语言中一个必不可少的元素就是方法，而字符串是对象的一种，所以有很多可用的方法。跟很多语言一样，Python使用以下形式来调用方法：对象.方法(参数)
 4. 字符串方法：
 * s.split()分割
 * s.join()联接
 * s.replace()替换
 * s.upper()方法返回一个将s中的字母全部大写的新字符串
 * s.lower()方法返回一个将s中的字母全部小写的新字符串
 * s.upper()方法返回一个将s中的字母全部大写的新字符串
 * s.lower()方法返回一个将s中的字母全部小写的新字符串
 5. **可以使用dir函数查看所有可以使用的方法**
 6. Python 用一对 """ 或者 ''' 来生成多行字符串：
 ```
 a = """hello world.
 it is a nice day."""
 ```
 7. 当代码太长或者为了美观起见时，我们可以使用两种方法来将一行代码转为多行代码：
 ```
 a = ("hello, world. "
    "it's a nice day. "
    "my name is xxx")
 a = "hello, world. " \
    "it's a nice day. " \
    "my name is xxx"
 ```
 8. 强制转换为字符串：
    * str(ob)强制将ob转化成字符串
    * repr(ob)也是强制将ob转化成字符串
 9. 可以将整数按照不同进制转化为不同类型的字符串：
    * 十六进制hex(255)
    * 八进制oct(255)
    * 二进制bin(255)
 10. 使用 int 将字符串转为整数，指定按照多少进制来进行转换，最后返回十进制表达的整数：
    * int('23')
    * int('FF', 16)
    * int('377', 8)
    * int('11111111', 2)
 11. float 可以将字符串转换为浮点数：float('3.5')
 12. Python用字符串的format()方法来格式化字符串。具体用法如下，字符串中花括号 {} 的部分会被format传入的参数替代，传入的值可以是字符串，也可以是数字或者别的对象。
 ```
 '{} {} {}'.format('a', 'b', 'c')
 ```
 可以用数字指定传入参数的相对位置：
 ```
 '{2} {1} {0}'.format('a', 'b', 'c')
 ```
 还可以指定传入参数的名称：
 ```
 '{color} {n} {x}'.format(n=10, x=1.5, color='blue')
 ```
 可以在一起混用：
 ```
 '{color} {0} {x} {1}'.format(10, 'foo', x = 1.5, color='blue')
 ```
 可以用{<field name>:<format>}指定格式：
 ```
 from math import pi
 '{0:10} {1:10d} {2:10.2f}'.format('foo', 5, 2 * pi)
 ```
 也可以使用旧式的 % 方法进行格式化：
 ```
 s = "some numbers:"
 x = 1.34
 y = 2
 # 用百分号隔开，括号括起来
 t = "%s %f, %d" % (s, x, y)
 ```
 ### 索引和分片
 1. 对于一个有序序列，可以通过索引的方法来访问对应位置的值。字符串便是一个有序序列的例子，Python使用 [] 来对有序序列进行索引。
 2. Python中索引是从 0 开始的，所以索引 0 对应与序列的第 1 个元素。为了得到第 5 个元素，需要使用索引值 4 。
 3. 除了正向索引，Python还引入了负索引值的用法，即从后向前开始计数，例如，索引 -2 表示倒数第 2 个元素。
 4. 单个索引大于等于字符串的长度时，会报错。
 5. 分片用来从序列中提取出想要的子序列，其用法为：var[lower:upper:step]。其范围包括 lower ，但不包括 upper ，即 [lower, upper)， step 表示取值间隔大小，如果没有默认为1。也可以使用负索引来指定分片的范围。
 6. lower和upper可以省略，省略lower意味着从开头开始分片，省略upper意味着一直分片到结尾。
 7. 当step的值为负时，省略lower意味着从结尾开始分片，省略upper意味着一直分片到开头。
 ```
 s[:100]
 ```
 8. 当给定的upper超出字符串的长度（注意：因为不包含upper，所以可以等于）时，Python并不会报错，不过只会计算到结尾。
 9. 两种简单的情况：
 * 从头开始的n个元素；
  * 使用0-base：[0, n)
  * 使用1-base：[1, n+1)
 * 第i+1个元素到第i+n个元素。
  * 使用0-base：[i, n+i)
  * 使用1-base：[i+1, n+i+1)
 ### 列表
 1. 在Python中，列表是一个有序的序列。
 2. 列表用一对 [] 生成，中间的元素用 , 隔开，其中的元素不需要是同一类型，同时列表的长度也不固定。
 3. 空列表可以用 [] 或者 list() 生成。
 4. 基本操作：查看长度、加法（按顺序连接）、乘法（重复相加）
 5. 列表和字符串一样可以通过索引和分片来查看它的元素、反向索引、分片。
 6. 与字符串不同的是，列表可以通过索引和分片来修改。对于字符串，如果我们通过索引或者分片来修改，Python会报错。
 7. 对于连续的分片（即步长为 1 ），Python采用的是整段替换的方法，两者的元素个数并不需要相同。
 8. Python提供了删除列表中元素的方法 'del'。
 9. 用**in**来看某个元素是否在某个序列（不仅仅是列表）中，用**not in**来判断是否不在某个序列中。
 10. 列表中可以包含各种对象，甚至可以包含列表。
 11. 列表的方法：
 * l.count(ob) 返回列表中元素 ob 出现的次数。
 * l.index(ob) 返回列表中元素 ob 第一次出现的索引位置，如果 ob 不在 l 中会报错。
 * l.append(ob) 将元素 ob 添加到列表 l 的最后。注意：append每次只添加一个元素，并不会因为这个元素是序列而将其展开。
 * l.extend(lst) 将序列 lst 的元素依次添加到列表 l 的最后，作用相当于 l += lst。
 * l.insert(idx, ob) 在索引 idx 处插入 ob ，之后的元素依次后移。
 * l.remove(ob) 会将列表中第一个出现的 ob 删除，如果 ob 不在 l 中会报错。
 * l.pop(idx) 会将索引 idx 处的元素删除，并返回这个元素。
 * l.sort() 会将列表中的元素按照一定的规则排序。如果不想改变原来列表中的值，可以使用 sorted 函数。
 * l.reverse() 会将列表中的元素从后向前排列。
 * 如果不清楚用法，可以用**？**查看帮助。
 12. 列表是可变的，可以通过自身的方法改变，也可以通过索引改变。字符串不能通过索引改变，而字符串方法只是返回一个新字符串，并不改变原来的值。如果想改变字符串的值，可以用重新赋值的方法。
 13. 数据类型分类：
 |可变数据类型|不可变数据类型|
 |--|--|
 |`list`, `dictionary`, `set`, `numpy array`, `user defined objects`|`integer`, `float`, `long`, `complex`, `string`,`tuple`, `frozenset`|
 14. 字符串不可变的原因：
 * 列表可以通过以下的方法改变，而字符串不支持这样的变化。此时， a 和 b 指向同一块区域，改变 b 的值， a 也会同时改变。
 ```
 a = [1, 2, 3, 4]
 b = a
 ```
 * 是字符串与整数浮点数一样被认为是基本类型，而基本类型在Python中是不可变的。
 ### 元组
 1. 与列表相似，元组Tuple也是个有序序列，但是元组是不可变的，用()生成。
 2. 将列表转换为元组：
 ```
 a = [10, 11, 12, 13, 14]
 tuple(a)
 ```
 3. 由于元组是不可变的，所以只能有一些不可变的方法。
 4. 为什么需要元组：
 * 旧式字符串格式化中参数要用元组；
 * 在字典中当作键值；
 * 数据库的返回值；
 5. IPython 中用 magic 命令 %timeit 来计时，可以看到，元组的生成速度要比列表的生成速度快得多，相差大概一个数量级。
 ```
 %timeit [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
 %timeit (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25)
 ```
 6. 在遍历上，元组和列表的速度表现差不多。
 7. 元组的生成速度会比列表快很多，迭代速度快一点，索引速度差不多。
 ### 字典
 1. 字典 dictionary，在一些编程语言中也称为hash，map ，是一种由键值对组成的数据结构。一个词可以对应一个或者多个定义，但是这些定义只能通过这个词来进行查询。
 2. Python 使用 {} 或者 dict() 来创建一个空的字典。
 3. 当我们print一个字典时，Python并不一定按照插入键值的先后顺序进行显示,因为字典中的键本身不一定是有序的。**字典没有顺序**因此，Python中不能用支持用数字索引按顺序查看字典中的值，而且数字本身也有可能成为键值，这样会引起混淆。
 4. 出于hash的目的，Python中要求这些键值对的键必须是不可变的，而值可以是任意的Python对象。
 5. 键（或者值）的数据类型可以不同。
 6. 除了通常的定义方式，还可以通过 dict() 转化来生成字典。
 7. 利用索引直接更新键值对。
 8. 适合做键的类型：在不可变类型中，整数和字符串是字典中最常用的类型；而浮点数通常不推荐用来做键，会因为浮点数的精度问题引发错误。有时候，也可以使用元组作为键值。
 9. 元组是有序的。
 10. 字典的方法：
 * 用索引可以找到一个键对应的值，但是当字典中没有这个键的时候，Python会报错，这时候可以使用字典的 get 方法来处理这种情况，其用法如下：`d.get(key, default = None)`返回字典中键 key 对应的值，如果没有这个键，返回 default 指定的值（默认是 None ）。
* pop 方法可以用来弹出字典中某个键对应的值，同时也可以指定默认参数：`d.pop(key, default = None)`删除并返回字典中键 key 对应的值，如果没有这个键，返回 default 指定的值（默认是 None ）。
* 之前已经知道，可以通过索引来插入、修改单个键值对，但是如果想对多个键值对进行操作，这种方法就显得比较麻烦，好在有 update 方法：`d.update(newd)`将字典newd中的内容更新到d中去。
* `d.keys()` 返回一个由所有键组成的列表；
* `d.values()` 返回一个由所有值组成的列表；
* `d.items()` 返回一个由所有键值对元组组成的列表；
 11. in查询字典中是否有该键。
### 集合
1. 之前看到的列表和字符串都是一种有序序列，而集合 set 是一种无序的序列。
2. 因为集合是无序的，所以当集合中存在两个同样的元素的时候，Python只会保存其中的一个（唯一性）；同时为了确保其中不包含同样的元素，集合中放入的元素只能是不可变的对象（确定性）。
3. 可以用set()函数来显示的生成集合,也可以用{}的形式来创建集合。**但是**创建空集合的时候只能用set来创建，因为在Python中{}创建的是一个空的字典。
4. 也可以使用一个列表来初始化一个集合
```
a = set([1, 2, 3, 1])
```
5. 集合的操作：
* 并：可以用方法 a.union(b) 或者操作 a | b 实现。
* 交：可以用方法 a.intersection(b) 或者操作 a & b 实现。
* 差：可以用方法 a.difference(b) 或者操作 a - b 实现。
* 对称差：a 和b 的对称差集，返回在 a 或在 b 中，但是不同时在 a 和 b 中的元素组成的集合；可以用方法 a.symmetric_difference(b) 或者操作 a ^ b 实现（异或操作符）。
* 要判断 b 是不是 a 的子集，可以用 b.issubset(a) 方法，或者更简单的用操作 b <= a 。
6. 集合方法：
* s.add(a)跟列表的 append 方法类似，用来向集合添加单个元素。
* s.update(seq)跟列表的extend方法类似，用来向集合添加多个元素。
* s.remove(ob)从集合s中移除元素ob，如果不存在会报错。
* t.pop()由于集合没有顺序，不能像列表一样按照位置弹出元素，所以pop 方法删除并返回集合中任意一个元素，如果集合中没有元素会报错。
* t.discard()作用与 remove 一样，但是当元素在集合中不存在的时候不会报错。
* a.difference_update(b)从a中去除所有属于b的元素。
7. 对应于元组（tuple）与列表（list）的关系，对于集合（set），Python提供了一种叫做不可变集合（frozen set）的数据结构。
8. 与集合不同的是，不可变集合一旦创建就不可以改变。
9. 不可变集合的一个主要应用是用来作为字典的键，例如用一个字典来记录两个城市之间的距离。
### Python 赋值机制
1. 改变变量x的值，变量y的值也随着改变，这与Python内部的赋值机制有关。
```
x = [1, 2, 3]
y = x
x[1] = 100
print y
```
[1,100,3]<br>
2. 注意简单类型和容器类型的赋值区分[如何理解 Python 的赋值逻辑](https://www.cnblogs.com/andywenzhi/p/7453374.html)
3. 如果说 C 程序是通过操纵内存地址而间接操作数据(每个变量固定对应一个内存地址，所以说操纵变量就是操纵内存地址），数据处于被动地位，那么Python则是直接操纵数据，数据处于主动地位，变量只是作为一种引用关系而存在，而不再拥有存储功能。Python 的这种操作让数据成为主体，数据与数据之间直接进行交互。而数据在Python中被称为对象(Object)。

## 判断语句
1. 虽然都是用 if 关键词定义判断，但与C，Java等语言不同，Python不使用 {} 将 if 语句控制的区域包含起来。Python使用的是缩进方法。同时，也不需要用 () 将判断条件括起来。
2. 不同的缩进值表示不同的代码块
3. Python不仅仅可以使用布尔型变量作为条件，它可以直接在if中使用任何表达式作为条件。
4. 大部分表达式的值都会被当作True，但以下表达式值会被当作False：
* False
* None
* 0
* 空字符串，空列表，空字典，空集合

## 循环
1. Python会循环执行<statesments>，直到<condition>不满足为止。
```
while <condition>:
    <statesments>
```
2.空容器会被当成 False ，因此可以用 while 循环来读取容器中的所有元素。
```
plays = set(['Hamlet', 'Macbeth', 'King Lear'])
while plays:
    play = plays.pop()
    print 'Perform', play
```
3. for循环会遍历完<sequence>中所有元素为止
```
for <variable> in <sequence>:
    <indented block of code>
```
4.```for i in range(100000):```然而这种写法有一个缺点：在循环前，它会生成一个长度为 100000 的临时列表。生成列表的问题在于，会有一定的时间和内存消耗，当数字从 100000 变得更大时，时间和内存的消耗会更加明显。为了解决这个问题，我们可以使用 xrange 来代替 range 函数，其效果与range函数相同，但是 xrange 并不会一次性的产生所有的数据。
5.遇到 continue 的时候，程序会返回到循环的最开始重新执行。
6.遇到 break 的时候，程序会跳出循环，不管循环条件是不是满足。
7. 与if一样，while和for循环后面也可以跟着else语句，不过要和break一起连用。
* 当循环正常结束时，循环条件不满足， else被执行；
* 当循环被 break结束时，循环条件仍然满足， else不执行。

### 列表推导公式
1.更简单的方法来创建这个列表
```
values = [10, 21, 4, 7, 12]
squares = [x**2 for x in values]
```
2. 还可以在列表推导式中加入条件进行筛选
```
values = [10, 21, 4, 7, 12]
squares = [x**2 for x in values if x <= 10]
```
3. 也可以使用推导式生成集合和字典：
```
square_dict = {x: x**2 for x in values if x <= 10}
```
4. 计算上面例子中生成的列表中所有元素的和：
```
total = sum([x**2 for x in values if x <= 10])
```
但是，Python会生成这个列表，然后在将它放到垃圾回收机制中（因为没有变量指向它），这毫无疑问是种浪费。为了解决这种问题，与xrange()类似，Python使用产生式表达式来解决这个问题：
```
total = sum(x**2 for x in values if x <= 10)
```









 
 
 



 






 

 

